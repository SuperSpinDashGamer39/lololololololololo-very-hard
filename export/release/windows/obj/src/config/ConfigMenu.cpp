// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Controls
#include <Controls.h>
#endif
#ifndef INCLUDED_ImageCache
#include <ImageCache.h>
#endif
#ifndef INCLUDED_MainMenuState
#include <MainMenuState.h>
#endif
#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PlayerSettings
#include <PlayerSettings.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_config_AutoOffsetState
#include <config/AutoOffsetState.h>
#endif
#ifndef INCLUDED_config_CacheSettings
#include <config/CacheSettings.h>
#endif
#ifndef INCLUDED_config_Config
#include <config/Config.h>
#endif
#ifndef INCLUDED_config_ConfigMenu
#include <config/ConfigMenu.h>
#endif
#ifndef INCLUDED_config_KeyBindMenu
#include <config/KeyBindMenu.h>
#endif
#ifndef INCLUDED_config_KeyBindMenuController
#include <config/KeyBindMenuController.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionData
#include <flixel/addons/transition/TransitionData.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxAction
#include <flixel/input/actions/FlxAction.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionDigital
#include <flixel/input/actions/FlxActionDigital.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionSet
#include <flixel/input/actions/FlxActionSet.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard__FlxKey_FlxKey_Impl_
#include <flixel/input/keyboard/_FlxKey/FlxKey_Impl_.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSoundGroup
#include <flixel/system/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextFormat
#include <flixel/text/FlxTextFormat.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_NumTween
#include <flixel/tweens/misc/NumTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_system_System
#include <openfl/system/System.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_23_new,"config.ConfigMenu","new",0x5657233f,"config.ConfigMenu.new","config/ConfigMenu.hx",23,0x0ffa9c70)
static const ::String _hx_array_data_3b9f17cd_1[] = {
	HX_("LEFT: DPAD LEFT / X (SQUARE) / LEFT TRIGGER\nDOWN: DPAD DOWN / X (CROSS) / LEFT BUMPER\nUP: DPAD UP / Y (TRIANGLE) / RIGHT BUMPER\nRIGHT: DPAD RIGHT / B (CIRCLE) / RIGHT TRIGGER",76,d5,49,71),HX_("LEFT: DPAD LEFT / DPAD DOWN / LEFT TRIGGER\nDOWN: DPAD UP / DPAD RIGHT / LEFT BUMPER\nUP: X (SQUARE) / Y (TRIANGLE) / RIGHT BUMPER\nRIGHT: A (CROSS) / B (CIRCLE) / RIGHT TRIGGER",5d,f8,9d,cb),HX_("LEFT: ALL DPAD DIRECTIONS\nDOWN: LEFT BUMPER / LEFT TRIGGER\nUP: RIGHT BUMPER / RIGHT TRIGGER\nRIGHT: ALL FACE BUTTONS",3d,64,f3,c8),HX_("Press A (CROSS) to change controller binds.",66,6f,54,83),
};
static const ::String _hx_array_data_3b9f17cd_2[] = {
	HX_("DEFAULT",a1,ac,97,1b),HX_("ALT 1",5a,c5,87,9f),HX_("ALT 2",5b,c5,87,9f),HX_("[CUSTOM]",91,98,66,35),
};
static const ::String _hx_array_data_3b9f17cd_3[] = {
	HX_("Ratings and combo count are a part of the world and move around with the camera.",67,15,f7,27),HX_("Ratings and combo count are a part of the hud and stay in a static position.",84,61,70,2c),HX_("Ratings and combo count are hidden.",c2,78,ec,86),
};
static const ::String _hx_array_data_3b9f17cd_4[] = {
	HX_("Any key press that isn't for a valid note will cause you to miss.",15,b9,a7,b0),HX_("You can only  miss while you need to sing.",0d,25,40,a9),HX_("You cannot miss unless you do not hit a note.\n[Note that this makes the game very easy and can remove a lot of the challenge.]",44,6b,e3,31),
};
static const ::String _hx_array_data_3b9f17cd_5[] = {
	HX_("NOTE OFFSET",01,fe,ff,81),HX_("ACCURACY DISPLAY",3b,39,fd,7f),HX_("UNCAPPED FRAMERATE",e3,3f,e8,df),HX_("ALLOW GHOST TAPPING",4d,ae,54,45),HX_("HP GAIN MULTIPLIER",6a,60,44,b9),HX_("HP DRAIN MULTIPLIER",21,cf,ef,93),HX_("DOWNSCROLL",ef,b9,dd,41),HX_("NOTE GLOW",7b,b9,c4,c3),HX_("COMBO DISPLAY",30,80,78,5b),HX_("BACKGROUND DIM",f6,43,6f,a4),HX_("[PRELOAD SETTINGS]",28,c8,b8,f8),HX_("CONTROLLER SCHEME",29,a3,41,50),HX_("[EDIT KEY BINDS]",83,9c,27,24),
};
static const ::String _hx_array_data_3b9f17cd_6[] = {
	HX_("on",1f,61,00,00),HX_("off",6f,93,54,00),
};
static const ::String _hx_array_data_3b9f17cd_7[] = {
	HX_("never",8c,3e,30,99),HX_("not singing",e6,f9,a3,bf),HX_("always",cf,0e,d7,46),
};
static const ::String _hx_array_data_3b9f17cd_8[] = {
	HX_("world",52,96,64,ce),HX_("hud",b7,50,4f,00),HX_("off",6f,93,54,00),
};
static const ::String _hx_array_data_3b9f17cd_9[] = {
	HX_("none",b8,12,0a,49),HX_("simple",32,04,7f,b8),HX_("complex",30,66,71,83),
};
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_122_create,"config.ConfigMenu","create",0x50d1e97d,"config.ConfigMenu.create","config/ConfigMenu.hx",122,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_206_update,"config.ConfigMenu","update",0x5bc8088a,"config.ConfigMenu.update","config/ConfigMenu.hx",206,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_537_changeItem,"config.ConfigMenu","changeItem",0xdbe551a4,"config.ConfigMenu.changeItem","config/ConfigMenu.hx",537,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_547_textUpdate,"config.ConfigMenu","textUpdate",0x79d25d97,"config.ConfigMenu.textUpdate","config/ConfigMenu.hx",547,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_591_getSetting,"config.ConfigMenu","getSetting",0x32e5be9b,"config.ConfigMenu.getSetting","config/ConfigMenu.hx",591,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_613_exit,"config.ConfigMenu","exit",0x3003275f,"config.ConfigMenu.exit","config/ConfigMenu.hx",613,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_621_secretPresetTest,"config.ConfigMenu","secretPresetTest",0x97eecfa2,"config.ConfigMenu.secretPresetTest","config/ConfigMenu.hx",621,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_648_writeToConfig,"config.ConfigMenu","writeToConfig",0x4a8fde3b,"config.ConfigMenu.writeToConfig","config/ConfigMenu.hx",648,0x0ffa9c70)
HX_LOCAL_STACK_FRAME(_hx_pos_39aa2ae3e97c53ec_26_boot,"config.ConfigMenu","boot",0x2e00b473,"config.ConfigMenu.boot","config/ConfigMenu.hx",26,0x0ffa9c70)
namespace config{

void ConfigMenu_obj::__construct( ::flixel::addons::transition::TransitionData TransIn, ::flixel::addons::transition::TransitionData TransOut){
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_23_new)
HXLINE( 203)		this->selectedSomethin = false;
HXLINE( 111)		this->controlSchemesDesc = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_1,4);
HXLINE( 104)		this->controlSchemes = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_2,4);
HXLINE(  98)		this->comboDisplayDesc = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_3,3);
HXLINE(  92)		this->ghostTapDesc = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_4,3);
HXLINE(  77)		::String _hx_tmp;
HXDLIN(  77)		if (( (bool)(::flixel::FlxG_obj::save->data->__Field(HX_("ee1",d1,fb,4c,00),::hx::paccDynamic)) )) {
HXLINE(  77)			_hx_tmp = HX_("\nHold \"SHIFT\" to force the pixel calibration.\nHold \"CTRL\" to force the normal calibration.",d6,56,d2,05);
            		}
            		else {
HXLINE(  77)			_hx_tmp = HX_("",00,00,00,00);
            		}
HXLINE(  76)		this->settingDesc = ::Array_obj< ::String >::__new(13)->init(0,(HX_("Adjust note timings.\nPress \"ENTER\" to start the offset calibration.",78,fc,d7,69) + _hx_tmp))->init(1,HX_("What type of accuracy calculation you want to use. Simple is just notes hit / total notes. Complex also factors in how early or late a note was.",62,f4,90,c9))->init(2,HX_("Uncaps the framerate during gameplay.",f1,d0,d4,85))->init(3,HX_("TEMP",14,8b,ba,37))->init(4,HX_("Modifies how much Health you gain when hitting a note.",4f,b8,bf,4e))->init(5,HX_("Modifies how much Health you lose when missing a note.",de,8e,dd,e3))->init(6,HX_("Makes notes appear from the top instead the bottom.",77,60,e7,7d))->init(7,HX_("Makes note arrows glow if they are able to be hit.",28,7d,10,bc))->init(8,HX_("TEMP",14,8b,ba,37))->init(9,HX_("Adjusts how dark the background is.\nIt is recommended that you use the HUD combo display with a high background dim.",c9,c4,36,84))->init(10,HX_("Change what assets the game preloads on startup.\n[A restart is required for these changes.]",c8,21,3a,67))->init(11,HX_("TEMP",14,8b,ba,37))->init(12,HX_("Change key binds.",49,80,eb,28));
HXLINE(  59)		this->settingText = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_5,13);
HXLINE(  57)		this->genericOnOff = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_6,2);
HXLINE(  55)		this->leftRightCount = 0;
HXLINE(  53)		this->canChangeItems = true;
HXLINE(  51)		this->tabKeys = ::Array_obj< ::String >::__new(0);
HXLINE(  46)		this->randomTapTypes = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_7,3);
HXLINE(  42)		this->comboTypes = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_8,3);
HXLINE(  38)		this->accuracyTypes = ::Array_obj< ::String >::fromData( _hx_array_data_3b9f17cd_9,3);
HXLINE(  33)		this->configSelected = 0;
HXLINE(  23)		super::__construct(TransIn,TransOut);
            	}

Dynamic ConfigMenu_obj::__CreateEmpty() { return new ConfigMenu_obj; }

void *ConfigMenu_obj::_hx_vtable = 0;

Dynamic ConfigMenu_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ConfigMenu_obj > _hx_result = new ConfigMenu_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ConfigMenu_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3f706236) {
		if (inClassId<=(int)0x23a57bae) {
			if (inClassId<=(int)0x03aad747) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x03aad747;
			} else {
				return inClassId==(int)0x23a57bae;
			}
		} else {
			return inClassId==(int)0x2f064378 || inClassId==(int)0x3f706236;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void ConfigMenu_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_122_create)
HXLINE( 123)		if (::hx::IsNull( ::config::ConfigMenu_obj::exitTo )) {
HXLINE( 124)			::config::ConfigMenu_obj::exitTo =  ::MainMenuState_obj::__alloc( HX_CTX ,null(),null());
            		}
HXLINE( 127)		if (::config::ConfigMenu_obj::startSong) {
HXLINE( 128)			::flixel::FlxG_obj::sound->playMusic((((HX_("assets/music/",36,ab,d2,e0) + HX_("configurator",f5,45,60,d6)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null());
            		}
            		else {
HXLINE( 130)			::config::ConfigMenu_obj::startSong = true;
            		}
HXLINE( 132)		this->persistentUpdate = (this->persistentDraw = true);
HXLINE( 134)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,-80,null(),null());
HXDLIN( 134)		::String data = ((HX_("assets/images/",ab,47,cb,9f) + HX_("menuDesat",26,91,04,72)) + HX_(".png",3b,2d,bd,1e));
HXDLIN( 134)		 ::Dynamic bg1;
HXDLIN( 134)		if (::ImageCache_obj::exists(data)) {
HXLINE( 134)			bg1 = ::ImageCache_obj::get(data);
            		}
            		else {
HXLINE( 134)			bg1 = data;
            		}
HXDLIN( 134)		 ::flixel::FlxSprite bg2 = bg->loadGraphic(bg1,null(),null(),null(),null(),null());
HXLINE( 135)		bg2->scrollFactor->set_x(( (Float)(0) ));
HXLINE( 136)		bg2->scrollFactor->set_y(( (Float)(0) ));
HXLINE( 137)		bg2->setGraphicSize(::Std_obj::_hx_int((bg2->get_width() * ((Float)1.18))),null());
HXLINE( 138)		bg2->updateHitbox();
HXLINE( 139)		bg2->screenCenter(null());
HXLINE( 140)		bg2->set_antialiasing(true);
HXLINE( 141)		bg2->set_color(-10720091);
HXLINE( 142)		this->add(bg2);
HXLINE( 144)		::config::Config_obj::reload();
HXLINE( 146)		this->offsetValue = ::config::Config_obj::offset;
HXLINE( 147)		this->accuracyType = ::config::Config_obj::accuracy;
HXLINE( 148)		this->accuracyTypeInt = this->accuracyTypes->indexOf(::config::Config_obj::accuracy,null());
HXLINE( 149)		this->healthValue = ::Std_obj::_hx_int((::config::Config_obj::healthMultiplier * ( (Float)(10) )));
HXLINE( 150)		this->healthDrainValue = ::Std_obj::_hx_int((::config::Config_obj::healthDrainMultiplier * ( (Float)(10) )));
HXLINE( 151)		this->comboValue = ::config::Config_obj::comboType;
HXLINE( 152)		this->downValue = ::config::Config_obj::downscroll;
HXLINE( 153)		this->glowValue = ::config::Config_obj::noteGlow;
HXLINE( 154)		this->randomTapValue = ::config::Config_obj::ghostTapType;
HXLINE( 155)		this->noCapValue = ::config::Config_obj::noFpsCap;
HXLINE( 156)		this->scheme = ::config::Config_obj::controllerScheme;
HXLINE( 157)		this->dimValue = ::config::Config_obj::bgDim;
HXLINE( 159)		::String data1 = ((HX_("assets/images/",ab,47,cb,9f) + HX_("FNF_main_menu_assets",be,dc,57,e2)) + HX_(".png",3b,2d,bd,1e));
HXDLIN( 159)		 ::Dynamic tex;
HXDLIN( 159)		if (::ImageCache_obj::exists(data1)) {
HXLINE( 159)			tex = ::ImageCache_obj::get(data1);
            		}
            		else {
HXLINE( 159)			tex = data1;
            		}
HXDLIN( 159)		 ::flixel::graphics::frames::FlxAtlasFrames tex1 = ::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(tex,((HX_("assets/images/",ab,47,cb,9f) + HX_("FNF_main_menu_assets",be,dc,57,e2)) + HX_(".xml",69,3e,c3,1e)));
HXLINE( 160)		 ::flixel::FlxSprite optionTitle =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,55,null());
HXLINE( 161)		optionTitle->set_frames(tex1);
HXLINE( 162)		optionTitle->animation->addByPrefix(HX_("selected",5b,2a,6d,b1),HX_("options white",67,e4,30,93),24,null(),null(),null());
HXLINE( 163)		optionTitle->animation->play(HX_("selected",5b,2a,6d,b1),null(),null(),null());
HXLINE( 164)		optionTitle->scrollFactor->set(null(),null());
HXLINE( 165)		optionTitle->set_antialiasing(true);
HXLINE( 166)		optionTitle->updateHitbox();
HXLINE( 167)		optionTitle->screenCenter(::flixel::util::FlxAxes_obj::X_dyn());
HXLINE( 169)		this->add(optionTitle);
HXLINE( 172)		this->configText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,215,1280,HX_("",00,00,00,00),42,null());
HXLINE( 173)		this->configText->scrollFactor->set(0,0);
HXLINE( 174)		this->configText->setFormat(HX_("assets/fonts/Funkin-Bold.otf",bd,87,d9,8a),42,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 175)		this->configText->set_borderSize(( (Float)(3) ));
HXLINE( 176)		this->configText->set_borderQuality(( (Float)(1) ));
HXLINE( 178)		this->descText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,320,638,640,HX_("",00,00,00,00),20,null());
HXLINE( 179)		this->descText->scrollFactor->set(0,0);
HXLINE( 180)		this->descText->setFormat(HX_("assets/fonts/vcr.ttf",46,38,26,7e),20,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 182)		this->descText->set_borderQuality(( (Float)(1) ));
HXLINE( 184)		int _hx_tmp = (::flixel::FlxG_obj::height - 53);
HXDLIN( 184)		this->tabDisplay =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,5,_hx_tmp,0,::Std_obj::string(this->tabKeys),16,null());
HXLINE( 185)		this->tabDisplay->scrollFactor->set(null(),null());
HXLINE( 186)		this->tabDisplay->set_visible(false);
HXLINE( 187)		this->tabDisplay->setFormat(HX_("VCR OSD Mono",be,44,e4,b8),16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 189)		 ::flixel::text::FlxText backText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,5,(::flixel::FlxG_obj::height - 37),0,HX_("ESCAPE - Back to Menu\nBACKSPACE - Reset to Defaults\n",e5,94,ab,e0),16,null());
HXLINE( 190)		backText->scrollFactor->set(null(),null());
HXLINE( 191)		backText->setFormat(HX_("VCR OSD Mono",be,44,e4,b8),16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 193)		this->add(this->configText);
HXLINE( 194)		this->add(this->descText);
HXLINE( 195)		this->add(this->tabDisplay);
HXLINE( 196)		this->add(backText);
HXLINE( 198)		this->textUpdate();
HXLINE( 200)		this->super::create();
            	}


void ConfigMenu_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_206_update)
HXLINE( 210)		if ((::flixel::FlxG_obj::sound->music->_volume < ((Float)0.8))) {
HXLINE( 212)			 ::flixel::_hx_system::FlxSound _g = ::flixel::FlxG_obj::sound->music;
HXDLIN( 212)			_g->set_volume((_g->_volume + (((Float)0.5) * ::flixel::FlxG_obj::elapsed)));
            		}
HXLINE( 215)		bool _hx_tmp;
HXDLIN( 215)		if (this->canChangeItems) {
HXLINE( 215)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 215)			_hx_tmp = !(_this->keyManager->checkStatus(9,_this->status));
            		}
            		else {
HXLINE( 215)			_hx_tmp = false;
            		}
HXDLIN( 215)		if (_hx_tmp) {
HXLINE( 216)			if (::PlayerSettings_obj::player1->controls->_upP->check()) {
HXLINE( 218)				::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 219)				this->changeItem(-1);
            			}
HXLINE( 222)			if (::PlayerSettings_obj::player1->controls->_downP->check()) {
HXLINE( 224)				::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 225)				this->changeItem(1);
            			}
HXLINE( 228)			switch((int)(this->configSelected)){
            				case (int)0: {
HXLINE( 230)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 232)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 233)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 233)						_hx_tmp->offsetValue = (_hx_tmp->offsetValue + 1);
            					}
HXLINE( 236)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 238)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 239)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 239)						_hx_tmp->offsetValue = (_hx_tmp->offsetValue - ( (Float)(1) ));
            					}
HXLINE( 242)					if (::PlayerSettings_obj::player1->controls->_right->check()) {
HXLINE( 244)						this->leftRightCount++;
HXLINE( 246)						if ((this->leftRightCount > 64)) {
HXLINE( 247)							 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 247)							_hx_tmp->offsetValue = (_hx_tmp->offsetValue + 1);
HXLINE( 248)							this->textUpdate();
            						}
            					}
HXLINE( 252)					if (::PlayerSettings_obj::player1->controls->_left->check()) {
HXLINE( 254)						this->leftRightCount++;
HXLINE( 256)						if ((this->leftRightCount > 64)) {
HXLINE( 257)							 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 257)							_hx_tmp->offsetValue = (_hx_tmp->offsetValue - ( (Float)(1) ));
HXLINE( 258)							this->textUpdate();
            						}
            					}
HXLINE( 262)					bool _hx_tmp;
HXDLIN( 262)					if (!(::PlayerSettings_obj::player1->controls->_right->check())) {
HXLINE( 262)						_hx_tmp = !(::PlayerSettings_obj::player1->controls->_left->check());
            					}
            					else {
HXLINE( 262)						_hx_tmp = false;
            					}
HXDLIN( 262)					if (_hx_tmp) {
HXLINE( 264)						this->leftRightCount = 0;
            					}
HXLINE( 267)					 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 267)					if (_this->keyManager->checkStatus(13,_this->status)) {
HXLINE( 268)						this->canChangeItems = false;
HXLINE( 269)						{
HXLINE( 269)							 ::flixel::_hx_system::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN( 269)							 ::Dynamic onComplete = null();
HXDLIN( 269)							if (::hx::IsNotNull( _this->fadeTween )) {
HXLINE( 269)								_this->fadeTween->cancel();
            							}
HXDLIN( 269)							_this->fadeTween = ::flixel::tweens::FlxTween_obj::num(_this->_volume,( (Float)(0) ),((Float)0.3), ::Dynamic(::hx::Anon_obj::Create(1)
            								->setFixed(0,HX_("onComplete",f8,d4,7e,5d),onComplete)),_this->volumeTween_dyn());
            						}
HXLINE( 270)						this->writeToConfig();
HXLINE( 271)						int _hx_tmp;
HXDLIN( 271)						 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 271)						if (_this1->keyManager->checkStatus(16,_this1->status)) {
HXLINE( 271)							_hx_tmp = 1;
            						}
            						else {
HXLINE( 271)							 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 271)							if (_this->keyManager->checkStatus(17,_this->status)) {
HXLINE( 271)								_hx_tmp = -1;
            							}
            							else {
HXLINE( 271)								_hx_tmp = 0;
            							}
            						}
HXDLIN( 271)						::config::AutoOffsetState_obj::forceEasterEgg = _hx_tmp;
HXLINE( 272)						{
HXLINE( 272)							 ::flixel::FlxState nextState =  ::config::AutoOffsetState_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 272)							if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 272)								::flixel::FlxG_obj::game->_requestedState = nextState;
            							}
            						}
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 276)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 278)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 279)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 279)						_hx_tmp->accuracyTypeInt = (_hx_tmp->accuracyTypeInt + 1);
            					}
HXLINE( 282)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 284)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 285)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 285)						_hx_tmp->accuracyTypeInt = (_hx_tmp->accuracyTypeInt - 1);
            					}
HXLINE( 288)					if ((this->accuracyTypeInt > 2)) {
HXLINE( 289)						this->accuracyTypeInt = 0;
            					}
HXLINE( 290)					if ((this->accuracyTypeInt < 0)) {
HXLINE( 291)						this->accuracyTypeInt = 2;
            					}
HXLINE( 293)					this->accuracyType = this->accuracyTypes->__get(this->accuracyTypeInt);
            				}
            				break;
            				case (int)2: {
HXLINE( 296)					bool _hx_tmp;
HXDLIN( 296)					bool _hx_tmp1;
HXDLIN( 296)					if (!(::PlayerSettings_obj::player1->controls->_rightP->check())) {
HXLINE( 296)						_hx_tmp1 = ::PlayerSettings_obj::player1->controls->_leftP->check();
            					}
            					else {
HXLINE( 296)						_hx_tmp1 = true;
            					}
HXDLIN( 296)					if (!(_hx_tmp1)) {
HXLINE( 296)						_hx_tmp = ::PlayerSettings_obj::player1->controls->_accept->check();
            					}
            					else {
HXLINE( 296)						_hx_tmp = true;
            					}
HXDLIN( 296)					if (_hx_tmp) {
HXLINE( 297)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 298)						this->noCapValue = !(this->noCapValue);
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 302)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 304)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 305)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 305)						_hx_tmp->randomTapValue = (_hx_tmp->randomTapValue + 1);
            					}
HXLINE( 308)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 310)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 311)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 311)						_hx_tmp->randomTapValue = (_hx_tmp->randomTapValue - 1);
            					}
HXLINE( 314)					if ((this->randomTapValue > 2)) {
HXLINE( 315)						this->randomTapValue = 0;
            					}
HXLINE( 316)					if ((this->randomTapValue < 0)) {
HXLINE( 317)						this->randomTapValue = 2;
            					}
            				}
            				break;
            				case (int)4: {
HXLINE( 319)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 321)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 322)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 322)						_hx_tmp->healthValue = (_hx_tmp->healthValue + 1);
            					}
HXLINE( 325)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 327)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 328)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 328)						_hx_tmp->healthValue = (_hx_tmp->healthValue - 1);
            					}
HXLINE( 331)					if ((this->healthValue > 100)) {
HXLINE( 332)						this->healthValue = 0;
            					}
HXLINE( 333)					if ((this->healthValue < 0)) {
HXLINE( 334)						this->healthValue = 100;
            					}
HXLINE( 336)					if (::PlayerSettings_obj::player1->controls->_right->check()) {
HXLINE( 338)						this->leftRightCount++;
HXLINE( 340)						bool _hx_tmp;
HXDLIN( 340)						if ((this->leftRightCount > 64)) {
HXLINE( 340)							_hx_tmp = (::hx::Mod(this->leftRightCount,10) == 0);
            						}
            						else {
HXLINE( 340)							_hx_tmp = false;
            						}
HXDLIN( 340)						if (_hx_tmp) {
HXLINE( 341)							 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 341)							_hx_tmp->healthValue = (_hx_tmp->healthValue + 1);
HXLINE( 342)							this->textUpdate();
            						}
            					}
HXLINE( 346)					if (::PlayerSettings_obj::player1->controls->_left->check()) {
HXLINE( 348)						this->leftRightCount++;
HXLINE( 350)						bool _hx_tmp;
HXDLIN( 350)						if ((this->leftRightCount > 64)) {
HXLINE( 350)							_hx_tmp = (::hx::Mod(this->leftRightCount,10) == 0);
            						}
            						else {
HXLINE( 350)							_hx_tmp = false;
            						}
HXDLIN( 350)						if (_hx_tmp) {
HXLINE( 351)							 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 351)							_hx_tmp->healthValue = (_hx_tmp->healthValue - 1);
HXLINE( 352)							this->textUpdate();
            						}
            					}
HXLINE( 356)					bool _hx_tmp;
HXDLIN( 356)					if (!(::PlayerSettings_obj::player1->controls->_right->check())) {
HXLINE( 356)						_hx_tmp = !(::PlayerSettings_obj::player1->controls->_left->check());
            					}
            					else {
HXLINE( 356)						_hx_tmp = false;
            					}
HXDLIN( 356)					if (_hx_tmp) {
HXLINE( 358)						this->leftRightCount = 0;
            					}
HXLINE( 361)					bool _hx_tmp1;
HXDLIN( 361)					if (!(::PlayerSettings_obj::player1->controls->_right->check())) {
HXLINE( 361)						_hx_tmp1 = !(::PlayerSettings_obj::player1->controls->_left->check());
            					}
            					else {
HXLINE( 361)						_hx_tmp1 = false;
            					}
HXDLIN( 361)					if (_hx_tmp1) {
HXLINE( 363)						this->leftRightCount = 0;
            					}
            				}
            				break;
            				case (int)5: {
HXLINE( 366)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 368)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 369)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 369)						_hx_tmp->healthDrainValue = (_hx_tmp->healthDrainValue + 1);
            					}
HXLINE( 372)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 374)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 375)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 375)						_hx_tmp->healthDrainValue = (_hx_tmp->healthDrainValue - 1);
            					}
HXLINE( 378)					if ((this->healthDrainValue > 100)) {
HXLINE( 379)						this->healthDrainValue = 0;
            					}
HXLINE( 380)					if ((this->healthDrainValue < 0)) {
HXLINE( 381)						this->healthDrainValue = 100;
            					}
HXLINE( 383)					if (::PlayerSettings_obj::player1->controls->_right->check()) {
HXLINE( 385)						this->leftRightCount++;
HXLINE( 387)						bool _hx_tmp;
HXDLIN( 387)						if ((this->leftRightCount > 64)) {
HXLINE( 387)							_hx_tmp = (::hx::Mod(this->leftRightCount,10) == 0);
            						}
            						else {
HXLINE( 387)							_hx_tmp = false;
            						}
HXDLIN( 387)						if (_hx_tmp) {
HXLINE( 388)							 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 388)							_hx_tmp->healthDrainValue = (_hx_tmp->healthDrainValue + 1);
HXLINE( 389)							this->textUpdate();
            						}
            					}
HXLINE( 393)					if (::PlayerSettings_obj::player1->controls->_left->check()) {
HXLINE( 395)						this->leftRightCount++;
HXLINE( 397)						bool _hx_tmp;
HXDLIN( 397)						if ((this->leftRightCount > 64)) {
HXLINE( 397)							_hx_tmp = (::hx::Mod(this->leftRightCount,10) == 0);
            						}
            						else {
HXLINE( 397)							_hx_tmp = false;
            						}
HXDLIN( 397)						if (_hx_tmp) {
HXLINE( 398)							 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 398)							_hx_tmp->healthDrainValue = (_hx_tmp->healthDrainValue - 1);
HXLINE( 399)							this->textUpdate();
            						}
            					}
HXLINE( 403)					bool _hx_tmp;
HXDLIN( 403)					if (!(::PlayerSettings_obj::player1->controls->_right->check())) {
HXLINE( 403)						_hx_tmp = !(::PlayerSettings_obj::player1->controls->_left->check());
            					}
            					else {
HXLINE( 403)						_hx_tmp = false;
            					}
HXDLIN( 403)					if (_hx_tmp) {
HXLINE( 405)						this->leftRightCount = 0;
            					}
            				}
            				break;
            				case (int)6: {
HXLINE( 408)					bool _hx_tmp;
HXDLIN( 408)					bool _hx_tmp1;
HXDLIN( 408)					if (!(::PlayerSettings_obj::player1->controls->_rightP->check())) {
HXLINE( 408)						_hx_tmp1 = ::PlayerSettings_obj::player1->controls->_leftP->check();
            					}
            					else {
HXLINE( 408)						_hx_tmp1 = true;
            					}
HXDLIN( 408)					if (!(_hx_tmp1)) {
HXLINE( 408)						_hx_tmp = ::PlayerSettings_obj::player1->controls->_accept->check();
            					}
            					else {
HXLINE( 408)						_hx_tmp = true;
            					}
HXDLIN( 408)					if (_hx_tmp) {
HXLINE( 409)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 410)						this->downValue = !(this->downValue);
            					}
            				}
            				break;
            				case (int)7: {
HXLINE( 413)					bool _hx_tmp;
HXDLIN( 413)					bool _hx_tmp1;
HXDLIN( 413)					if (!(::PlayerSettings_obj::player1->controls->_rightP->check())) {
HXLINE( 413)						_hx_tmp1 = ::PlayerSettings_obj::player1->controls->_leftP->check();
            					}
            					else {
HXLINE( 413)						_hx_tmp1 = true;
            					}
HXDLIN( 413)					if (!(_hx_tmp1)) {
HXLINE( 413)						_hx_tmp = ::PlayerSettings_obj::player1->controls->_accept->check();
            					}
            					else {
HXLINE( 413)						_hx_tmp = true;
            					}
HXDLIN( 413)					if (_hx_tmp) {
HXLINE( 414)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 415)						this->glowValue = !(this->glowValue);
            					}
            				}
            				break;
            				case (int)8: {
HXLINE( 418)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 420)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 421)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 421)						_hx_tmp->comboValue = (_hx_tmp->comboValue + 1);
            					}
HXLINE( 424)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 426)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 427)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 427)						_hx_tmp->comboValue = (_hx_tmp->comboValue - 1);
            					}
HXLINE( 430)					if ((this->comboValue >= this->comboTypes->length)) {
HXLINE( 431)						this->comboValue = 0;
            					}
HXLINE( 432)					if ((this->comboValue < 0)) {
HXLINE( 433)						this->comboValue = (this->comboTypes->length - 1);
            					}
            				}
            				break;
            				case (int)9: {
HXLINE( 435)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 437)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 438)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 438)						_hx_tmp->dimValue = (_hx_tmp->dimValue + 1);
            					}
HXLINE( 441)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 443)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 444)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 444)						_hx_tmp->dimValue = (_hx_tmp->dimValue - 1);
            					}
HXLINE( 447)					if ((this->dimValue > 10)) {
HXLINE( 448)						this->dimValue = 0;
            					}
HXLINE( 449)					if ((this->dimValue < 0)) {
HXLINE( 450)						this->dimValue = 10;
            					}
            				}
            				break;
            				case (int)10: {
HXLINE( 453)					if (::PlayerSettings_obj::player1->controls->_accept->check()) {
HXLINE( 455)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 456)						this->canChangeItems = false;
HXLINE( 457)						this->writeToConfig();
HXLINE( 458)						{
HXLINE( 458)							 ::flixel::FlxState nextState =  ::config::CacheSettings_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 458)							if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 458)								::flixel::FlxG_obj::game->_requestedState = nextState;
            							}
            						}
HXLINE( 459)						::config::CacheSettings_obj::returnLoc =  ::config::ConfigMenu_obj::__alloc( HX_CTX ,null(),null());
            					}
            				}
            				break;
            				case (int)11: {
HXLINE( 464)					if (::PlayerSettings_obj::player1->controls->_rightP->check()) {
HXLINE( 466)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 467)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 467)						_hx_tmp->scheme = (_hx_tmp->scheme + 1);
            					}
HXLINE( 470)					if (::PlayerSettings_obj::player1->controls->_leftP->check()) {
HXLINE( 472)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 473)						 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 473)						_hx_tmp->scheme = (_hx_tmp->scheme - 1);
            					}
HXLINE( 476)					if ((this->scheme >= this->controlSchemes->length)) {
HXLINE( 477)						this->scheme = 0;
            					}
HXLINE( 478)					if ((this->scheme < 0)) {
HXLINE( 479)						this->scheme = (this->controlSchemes->length - 1);
            					}
HXLINE( 481)					bool _hx_tmp;
HXDLIN( 481)					if (::PlayerSettings_obj::player1->controls->_accept->check()) {
HXLINE( 481)						_hx_tmp = (this->scheme == (this->controlSchemes->length - 1));
            					}
            					else {
HXLINE( 481)						_hx_tmp = false;
            					}
HXDLIN( 481)					if (_hx_tmp) {
HXLINE( 482)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 483)						this->canChangeItems = false;
HXLINE( 484)						this->writeToConfig();
HXLINE( 485)						{
HXLINE( 485)							 ::flixel::FlxState nextState =  ::config::KeyBindMenuController_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 485)							if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 485)								::flixel::FlxG_obj::game->_requestedState = nextState;
            							}
            						}
            					}
            				}
            				break;
            				case (int)12: {
HXLINE( 489)					if (::PlayerSettings_obj::player1->controls->_accept->check()) {
HXLINE( 490)						::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("scrollMenu",4c,d4,18,06)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 491)						this->canChangeItems = false;
HXLINE( 492)						this->writeToConfig();
HXLINE( 493)						{
HXLINE( 493)							 ::flixel::FlxState nextState =  ::config::KeyBindMenu_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 493)							if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 493)								::flixel::FlxG_obj::game->_requestedState = nextState;
            							}
            						}
            					}
            				}
            				break;
            			}
            		}
            		else {
HXLINE( 498)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 498)			if (_this->keyManager->checkStatus(9,_this->status)) {
HXLINE( 499)				if (( ( ::flixel::input::FlxBaseKeyList)(::flixel::FlxG_obj::keys->justPressed) )->get_ANY()) {
HXLINE( 500)					int this1 = ( (int)(::flixel::FlxG_obj::keys->getIsDown()->__get(0).StaticCast<  ::flixel::input::FlxInput >()->ID) );
HXDLIN( 500)					if (::hx::IsNotEq( ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::toStringMap->get(this1),HX_("TAB",35,f6,3f,00) )) {
HXLINE( 501)						::Array< ::String > _hx_tmp = this->tabKeys;
HXDLIN( 501)						int this1 = ( (int)(::flixel::FlxG_obj::keys->getIsDown()->__get(0).StaticCast<  ::flixel::input::FlxInput >()->ID) );
HXDLIN( 501)						_hx_tmp->push(::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::toStringMap->get(this1));
            					}
            				}
            			}
            		}
HXLINE( 506)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 506)		if (_this->keyManager->checkStatus(9,_this->status)) {
HXLINE( 507)			this->tabDisplay->set_visible(true);
            		}
HXLINE( 510)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justReleased) );
HXDLIN( 510)		if (_this1->keyManager->checkStatus(9,_this1->status)) {
HXLINE( 511)			this->secretPresetTest(this->tabKeys);
HXLINE( 512)			this->tabKeys = ::Array_obj< ::String >::__new(0);
HXLINE( 513)			this->tabDisplay->set_visible(false);
            		}
HXLINE( 516)		if (::PlayerSettings_obj::player1->controls->_back->check()) {
HXLINE( 518)			this->writeToConfig();
HXLINE( 519)			this->exit();
            		}
HXLINE( 522)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 522)		if (_this2->keyManager->checkStatus(8,_this2->status)) {
HXLINE( 524)			::config::Config_obj::resetSettings();
HXLINE( 525)			::flixel::FlxG_obj::save->data->__SetField(HX_("ee1",d1,fb,4c,00),false,::hx::paccDynamic);
HXLINE( 526)			this->exit();
            		}
HXLINE( 529)		this->super::update(elapsed);
HXLINE( 531)		bool _hx_tmp1;
HXDLIN( 531)		bool _hx_tmp2;
HXDLIN( 531)		bool _hx_tmp3;
HXDLIN( 531)		bool _hx_tmp4;
HXDLIN( 531)		bool _hx_tmp5;
HXDLIN( 531)		if (!(::PlayerSettings_obj::player1->controls->_leftP->check())) {
HXLINE( 531)			_hx_tmp5 = ::PlayerSettings_obj::player1->controls->_rightP->check();
            		}
            		else {
HXLINE( 531)			_hx_tmp5 = true;
            		}
HXDLIN( 531)		if (!(_hx_tmp5)) {
HXLINE( 531)			_hx_tmp4 = ::PlayerSettings_obj::player1->controls->_upP->check();
            		}
            		else {
HXLINE( 531)			_hx_tmp4 = true;
            		}
HXDLIN( 531)		if (!(_hx_tmp4)) {
HXLINE( 531)			_hx_tmp3 = ::PlayerSettings_obj::player1->controls->_downP->check();
            		}
            		else {
HXLINE( 531)			_hx_tmp3 = true;
            		}
HXDLIN( 531)		if (!(_hx_tmp3)) {
HXLINE( 531)			_hx_tmp2 = ::PlayerSettings_obj::player1->controls->_accept->check();
            		}
            		else {
HXLINE( 531)			_hx_tmp2 = true;
            		}
HXDLIN( 531)		if (!(_hx_tmp2)) {
HXLINE( 531)			_hx_tmp1 = ( ( ::flixel::input::FlxBaseKeyList)(::flixel::FlxG_obj::keys->justPressed) )->get_ANY();
            		}
            		else {
HXLINE( 531)			_hx_tmp1 = true;
            		}
HXDLIN( 531)		if (_hx_tmp1) {
HXLINE( 532)			this->textUpdate();
            		}
            	}


void ConfigMenu_obj::changeItem(::hx::Null< int >  __o_huh){
            		int huh = __o_huh.Default(0);
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_537_changeItem)
HXLINE( 538)		 ::config::ConfigMenu _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 538)		_hx_tmp->configSelected = (_hx_tmp->configSelected + huh);
HXLINE( 540)		if ((this->configSelected > (this->settingText->length - 1))) {
HXLINE( 541)			this->configSelected = 0;
            		}
HXLINE( 542)		if ((this->configSelected < 0)) {
HXLINE( 543)			this->configSelected = (this->settingText->length - 1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ConfigMenu_obj,changeItem,(void))

void ConfigMenu_obj::textUpdate(){
            	HX_GC_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_547_textUpdate)
HXLINE( 549)		this->configText->clearFormats();
HXLINE( 550)		this->configText->set_text(HX_("",00,00,00,00));
HXLINE( 552)		{
HXLINE( 552)			int _g = 0;
HXDLIN( 552)			int _g1 = this->settingText->length;
HXDLIN( 552)			while((_g < _g1)){
HXLINE( 552)				_g = (_g + 1);
HXDLIN( 552)				int i = (_g - 1);
HXLINE( 554)				int sectionStart = this->configText->text.length;
HXLINE( 555)				{
HXLINE( 555)					 ::flixel::text::FlxText _g1 = this->configText;
HXDLIN( 555)					::String _g2 = _g1->text;
HXDLIN( 555)					::String _hx_tmp = this->settingText->__get(i);
HXDLIN( 555)					_g1->set_text((_g2 + ((_hx_tmp + this->getSetting(i)) + HX_("\n",0a,00,00,00))));
            				}
HXLINE( 556)				int sectionEnd = (this->configText->text.length - 1);
HXLINE( 558)				if ((i == this->configSelected)) {
HXLINE( 560)					 ::flixel::text::FlxText _hx_tmp = this->configText;
HXDLIN( 560)					_hx_tmp->addFormat( ::flixel::text::FlxTextFormat_obj::__alloc( HX_CTX ,-256,null(),null(),null()),sectionStart,sectionEnd);
            				}
            			}
            		}
HXLINE( 565)		switch((int)(this->configSelected)){
            			case (int)3: {
HXLINE( 568)				this->descText->set_text(this->ghostTapDesc->__get(this->randomTapValue));
            			}
            			break;
            			case (int)8: {
HXLINE( 571)				this->descText->set_text(this->comboDisplayDesc->__get(this->comboValue));
            			}
            			break;
            			case (int)10: {
HXLINE( 574)				this->descText->set_text(this->settingDesc->__get(this->configSelected));
            			}
            			break;
            			case (int)11: {
HXLINE( 580)				this->descText->set_text(this->controlSchemesDesc->__get(this->scheme));
            			}
            			break;
            			default:{
HXLINE( 583)				this->descText->set_text(this->settingDesc->__get(this->configSelected));
            			}
            		}
HXLINE( 587)		 ::flixel::text::FlxText _hx_tmp = this->tabDisplay;
HXDLIN( 587)		_hx_tmp->set_text(::Std_obj::string(this->tabKeys));
            	}


HX_DEFINE_DYNAMIC_FUNC0(ConfigMenu_obj,textUpdate,(void))

::String ConfigMenu_obj::getSetting(int r){
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_591_getSetting)
HXLINE( 593)		switch((int)(r)){
            			case (int)0: {
HXLINE( 595)				return (HX_(": ",a6,32,00,00) + this->offsetValue);
            			}
            			break;
            			case (int)1: {
HXLINE( 596)				return (HX_(": ",a6,32,00,00) + this->accuracyType);
            			}
            			break;
            			case (int)2: {
HXLINE( 597)				int _hx_tmp;
HXDLIN( 597)				if (this->noCapValue) {
HXLINE( 597)					_hx_tmp = 0;
            				}
            				else {
HXLINE( 597)					_hx_tmp = 1;
            				}
HXDLIN( 597)				return (HX_(": ",a6,32,00,00) + this->genericOnOff->__get(_hx_tmp));
            			}
            			break;
            			case (int)3: {
HXLINE( 598)				return (HX_(": ",a6,32,00,00) + this->randomTapTypes->__get(this->randomTapValue));
            			}
            			break;
            			case (int)4: {
HXLINE( 599)				return (HX_(": ",a6,32,00,00) + (( (Float)(this->healthValue) ) / ((Float)10.0)));
            			}
            			break;
            			case (int)5: {
HXLINE( 600)				return (HX_(": ",a6,32,00,00) + (( (Float)(this->healthDrainValue) ) / ((Float)10.0)));
            			}
            			break;
            			case (int)6: {
HXLINE( 601)				int _hx_tmp;
HXDLIN( 601)				if (this->downValue) {
HXLINE( 601)					_hx_tmp = 0;
            				}
            				else {
HXLINE( 601)					_hx_tmp = 1;
            				}
HXDLIN( 601)				return (HX_(": ",a6,32,00,00) + this->genericOnOff->__get(_hx_tmp));
            			}
            			break;
            			case (int)7: {
HXLINE( 602)				int _hx_tmp;
HXDLIN( 602)				if (this->glowValue) {
HXLINE( 602)					_hx_tmp = 0;
            				}
            				else {
HXLINE( 602)					_hx_tmp = 1;
            				}
HXDLIN( 602)				return (HX_(": ",a6,32,00,00) + this->genericOnOff->__get(_hx_tmp));
            			}
            			break;
            			case (int)8: {
HXLINE( 603)				return (HX_(": ",a6,32,00,00) + this->comboTypes->__get(this->comboValue));
            			}
            			break;
            			case (int)9: {
HXLINE( 604)				return ((HX_(": ",a6,32,00,00) + (this->dimValue * 10)) + HX_("%",25,00,00,00));
            			}
            			break;
            			case (int)11: {
HXLINE( 605)				return (HX_(": ",a6,32,00,00) + this->controlSchemes->__get(this->scheme));
            			}
            			break;
            		}
HXLINE( 609)		return HX_("",00,00,00,00);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ConfigMenu_obj,getSetting,return )

void ConfigMenu_obj::exit(){
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_613_exit)
HXLINE( 614)		this->canChangeItems = false;
HXLINE( 615)		{
HXLINE( 615)			 ::flixel::_hx_system::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN( 615)			_this->cleanup(_this->autoDestroy,true);
            		}
HXLINE( 616)		::flixel::FlxG_obj::sound->play((((HX_("assets/sounds/",1f,fa,fb,94) + HX_("cancelMenu",39,a4,43,b7)) + HX_(".",2e,00,00,00)) + ::Paths_obj::audioExtension),null(),null(),null(),null(),null());
HXLINE( 617)		{
HXLINE( 617)			 ::flixel::FlxState nextState = ::config::ConfigMenu_obj::exitTo;
HXDLIN( 617)			if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 617)				::flixel::FlxG_obj::game->_requestedState = nextState;
            			}
            		}
HXLINE( 618)		::config::ConfigMenu_obj::exitTo = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(ConfigMenu_obj,exit,(void))

void ConfigMenu_obj::secretPresetTest(::Array< ::String > _combo){
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_621_secretPresetTest)
HXLINE( 623)		::String combo = HX_("",00,00,00,00);
HXLINE( 625)		{
HXLINE( 625)			int _g = 0;
HXDLIN( 625)			while((_g < _combo->length)){
HXLINE( 625)				::String x = _combo->__get(_g);
HXDLIN( 625)				_g = (_g + 1);
HXLINE( 626)				combo = (combo + x);
            			}
            		}
HXLINE( 629)		::String _hx_switch_0 = combo;
            		if (  (_hx_switch_0==HX_("CVAL",5e,c6,8a,2c)) ){
HXLINE( 638)			::config::Config_obj::write(this->offsetValue,HX_("simple",32,04,7f,b8),( (Float)(1) ),( (Float)(1) ),this->comboValue,false,this->glowValue,1,this->noCapValue,this->scheme,this->dimValue);
HXLINE( 639)			this->exit();
HXLINE( 637)			goto _hx_goto_18;
            		}
            		if (  (_hx_switch_0==HX_("GOTOHELLORSOMETHING",f7,40,2b,2a)) ){
HXLINE( 641)			::openfl::_hx_system::System_obj::exit(0);
HXDLIN( 641)			goto _hx_goto_18;
            		}
            		if (  (_hx_switch_0==HX_("KADE",97,8e,c4,31)) ){
HXLINE( 632)			::config::Config_obj::write(this->offsetValue,HX_("complex",30,66,71,83),( (Float)(5) ),( (Float)(5) ),1,this->downValue,false,2,this->noCapValue,this->scheme,this->dimValue);
HXLINE( 633)			this->exit();
HXLINE( 631)			goto _hx_goto_18;
            		}
            		if (  (_hx_switch_0==HX_("ROZE",a8,bf,6f,36)) ){
HXLINE( 635)			::config::Config_obj::write(this->offsetValue,HX_("simple",32,04,7f,b8),( (Float)(1) ),( (Float)(1) ),0,true,true,0,this->noCapValue,this->scheme,this->dimValue);
HXLINE( 636)			this->exit();
HXLINE( 634)			goto _hx_goto_18;
            		}
            		_hx_goto_18:;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ConfigMenu_obj,secretPresetTest,(void))

void ConfigMenu_obj::writeToConfig(){
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_648_writeToConfig)
HXDLIN( 648)		::config::Config_obj::write(this->offsetValue,this->accuracyType,(( (Float)(this->healthValue) ) / ((Float)10.0)),(( (Float)(this->healthDrainValue) ) / ((Float)10.0)),this->comboValue,this->downValue,this->glowValue,this->randomTapValue,this->noCapValue,this->scheme,this->dimValue);
            	}


HX_DEFINE_DYNAMIC_FUNC0(ConfigMenu_obj,writeToConfig,(void))

bool ConfigMenu_obj::startSong;

 ::flixel::FlxState ConfigMenu_obj::exitTo;


::hx::ObjectPtr< ConfigMenu_obj > ConfigMenu_obj::__new( ::flixel::addons::transition::TransitionData TransIn, ::flixel::addons::transition::TransitionData TransOut) {
	::hx::ObjectPtr< ConfigMenu_obj > __this = new ConfigMenu_obj();
	__this->__construct(TransIn,TransOut);
	return __this;
}

::hx::ObjectPtr< ConfigMenu_obj > ConfigMenu_obj::__alloc(::hx::Ctx *_hx_ctx, ::flixel::addons::transition::TransitionData TransIn, ::flixel::addons::transition::TransitionData TransOut) {
	ConfigMenu_obj *__this = (ConfigMenu_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ConfigMenu_obj), true, "config.ConfigMenu"));
	*(void **)__this = ConfigMenu_obj::_hx_vtable;
	__this->__construct(TransIn,TransOut);
	return __this;
}

ConfigMenu_obj::ConfigMenu_obj()
{
}

void ConfigMenu_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ConfigMenu);
	HX_MARK_MEMBER_NAME(configText,"configText");
	HX_MARK_MEMBER_NAME(descText,"descText");
	HX_MARK_MEMBER_NAME(tabDisplay,"tabDisplay");
	HX_MARK_MEMBER_NAME(configSelected,"configSelected");
	HX_MARK_MEMBER_NAME(offsetValue,"offsetValue");
	HX_MARK_MEMBER_NAME(accuracyType,"accuracyType");
	HX_MARK_MEMBER_NAME(accuracyTypeInt,"accuracyTypeInt");
	HX_MARK_MEMBER_NAME(accuracyTypes,"accuracyTypes");
	HX_MARK_MEMBER_NAME(healthValue,"healthValue");
	HX_MARK_MEMBER_NAME(healthDrainValue,"healthDrainValue");
	HX_MARK_MEMBER_NAME(comboValue,"comboValue");
	HX_MARK_MEMBER_NAME(comboTypes,"comboTypes");
	HX_MARK_MEMBER_NAME(downValue,"downValue");
	HX_MARK_MEMBER_NAME(glowValue,"glowValue");
	HX_MARK_MEMBER_NAME(randomTapValue,"randomTapValue");
	HX_MARK_MEMBER_NAME(randomTapTypes,"randomTapTypes");
	HX_MARK_MEMBER_NAME(noCapValue,"noCapValue");
	HX_MARK_MEMBER_NAME(scheme,"scheme");
	HX_MARK_MEMBER_NAME(dimValue,"dimValue");
	HX_MARK_MEMBER_NAME(tabKeys,"tabKeys");
	HX_MARK_MEMBER_NAME(canChangeItems,"canChangeItems");
	HX_MARK_MEMBER_NAME(leftRightCount,"leftRightCount");
	HX_MARK_MEMBER_NAME(genericOnOff,"genericOnOff");
	HX_MARK_MEMBER_NAME(settingText,"settingText");
	HX_MARK_MEMBER_NAME(settingDesc,"settingDesc");
	HX_MARK_MEMBER_NAME(ghostTapDesc,"ghostTapDesc");
	HX_MARK_MEMBER_NAME(comboDisplayDesc,"comboDisplayDesc");
	HX_MARK_MEMBER_NAME(controlSchemes,"controlSchemes");
	HX_MARK_MEMBER_NAME(controlSchemesDesc,"controlSchemesDesc");
	HX_MARK_MEMBER_NAME(selectedSomethin,"selectedSomethin");
	 ::flixel::addons::ui::FlxUIState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ConfigMenu_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(configText,"configText");
	HX_VISIT_MEMBER_NAME(descText,"descText");
	HX_VISIT_MEMBER_NAME(tabDisplay,"tabDisplay");
	HX_VISIT_MEMBER_NAME(configSelected,"configSelected");
	HX_VISIT_MEMBER_NAME(offsetValue,"offsetValue");
	HX_VISIT_MEMBER_NAME(accuracyType,"accuracyType");
	HX_VISIT_MEMBER_NAME(accuracyTypeInt,"accuracyTypeInt");
	HX_VISIT_MEMBER_NAME(accuracyTypes,"accuracyTypes");
	HX_VISIT_MEMBER_NAME(healthValue,"healthValue");
	HX_VISIT_MEMBER_NAME(healthDrainValue,"healthDrainValue");
	HX_VISIT_MEMBER_NAME(comboValue,"comboValue");
	HX_VISIT_MEMBER_NAME(comboTypes,"comboTypes");
	HX_VISIT_MEMBER_NAME(downValue,"downValue");
	HX_VISIT_MEMBER_NAME(glowValue,"glowValue");
	HX_VISIT_MEMBER_NAME(randomTapValue,"randomTapValue");
	HX_VISIT_MEMBER_NAME(randomTapTypes,"randomTapTypes");
	HX_VISIT_MEMBER_NAME(noCapValue,"noCapValue");
	HX_VISIT_MEMBER_NAME(scheme,"scheme");
	HX_VISIT_MEMBER_NAME(dimValue,"dimValue");
	HX_VISIT_MEMBER_NAME(tabKeys,"tabKeys");
	HX_VISIT_MEMBER_NAME(canChangeItems,"canChangeItems");
	HX_VISIT_MEMBER_NAME(leftRightCount,"leftRightCount");
	HX_VISIT_MEMBER_NAME(genericOnOff,"genericOnOff");
	HX_VISIT_MEMBER_NAME(settingText,"settingText");
	HX_VISIT_MEMBER_NAME(settingDesc,"settingDesc");
	HX_VISIT_MEMBER_NAME(ghostTapDesc,"ghostTapDesc");
	HX_VISIT_MEMBER_NAME(comboDisplayDesc,"comboDisplayDesc");
	HX_VISIT_MEMBER_NAME(controlSchemes,"controlSchemes");
	HX_VISIT_MEMBER_NAME(controlSchemesDesc,"controlSchemesDesc");
	HX_VISIT_MEMBER_NAME(selectedSomethin,"selectedSomethin");
	 ::flixel::addons::ui::FlxUIState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ConfigMenu_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"exit") ) { return ::hx::Val( exit_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"scheme") ) { return ::hx::Val( scheme ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tabKeys") ) { return ::hx::Val( tabKeys ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"descText") ) { return ::hx::Val( descText ); }
		if (HX_FIELD_EQ(inName,"dimValue") ) { return ::hx::Val( dimValue ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"downValue") ) { return ::hx::Val( downValue ); }
		if (HX_FIELD_EQ(inName,"glowValue") ) { return ::hx::Val( glowValue ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"configText") ) { return ::hx::Val( configText ); }
		if (HX_FIELD_EQ(inName,"tabDisplay") ) { return ::hx::Val( tabDisplay ); }
		if (HX_FIELD_EQ(inName,"comboValue") ) { return ::hx::Val( comboValue ); }
		if (HX_FIELD_EQ(inName,"comboTypes") ) { return ::hx::Val( comboTypes ); }
		if (HX_FIELD_EQ(inName,"noCapValue") ) { return ::hx::Val( noCapValue ); }
		if (HX_FIELD_EQ(inName,"changeItem") ) { return ::hx::Val( changeItem_dyn() ); }
		if (HX_FIELD_EQ(inName,"textUpdate") ) { return ::hx::Val( textUpdate_dyn() ); }
		if (HX_FIELD_EQ(inName,"getSetting") ) { return ::hx::Val( getSetting_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"offsetValue") ) { return ::hx::Val( offsetValue ); }
		if (HX_FIELD_EQ(inName,"healthValue") ) { return ::hx::Val( healthValue ); }
		if (HX_FIELD_EQ(inName,"settingText") ) { return ::hx::Val( settingText ); }
		if (HX_FIELD_EQ(inName,"settingDesc") ) { return ::hx::Val( settingDesc ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"accuracyType") ) { return ::hx::Val( accuracyType ); }
		if (HX_FIELD_EQ(inName,"genericOnOff") ) { return ::hx::Val( genericOnOff ); }
		if (HX_FIELD_EQ(inName,"ghostTapDesc") ) { return ::hx::Val( ghostTapDesc ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"accuracyTypes") ) { return ::hx::Val( accuracyTypes ); }
		if (HX_FIELD_EQ(inName,"writeToConfig") ) { return ::hx::Val( writeToConfig_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"configSelected") ) { return ::hx::Val( configSelected ); }
		if (HX_FIELD_EQ(inName,"randomTapValue") ) { return ::hx::Val( randomTapValue ); }
		if (HX_FIELD_EQ(inName,"randomTapTypes") ) { return ::hx::Val( randomTapTypes ); }
		if (HX_FIELD_EQ(inName,"canChangeItems") ) { return ::hx::Val( canChangeItems ); }
		if (HX_FIELD_EQ(inName,"leftRightCount") ) { return ::hx::Val( leftRightCount ); }
		if (HX_FIELD_EQ(inName,"controlSchemes") ) { return ::hx::Val( controlSchemes ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"accuracyTypeInt") ) { return ::hx::Val( accuracyTypeInt ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"healthDrainValue") ) { return ::hx::Val( healthDrainValue ); }
		if (HX_FIELD_EQ(inName,"comboDisplayDesc") ) { return ::hx::Val( comboDisplayDesc ); }
		if (HX_FIELD_EQ(inName,"selectedSomethin") ) { return ::hx::Val( selectedSomethin ); }
		if (HX_FIELD_EQ(inName,"secretPresetTest") ) { return ::hx::Val( secretPresetTest_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"controlSchemesDesc") ) { return ::hx::Val( controlSchemesDesc ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ConfigMenu_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"exitTo") ) { outValue = ( exitTo ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"startSong") ) { outValue = ( startSong ); return true; }
	}
	return false;
}

::hx::Val ConfigMenu_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"scheme") ) { scheme=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tabKeys") ) { tabKeys=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"descText") ) { descText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dimValue") ) { dimValue=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"downValue") ) { downValue=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"glowValue") ) { glowValue=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"configText") ) { configText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tabDisplay") ) { tabDisplay=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"comboValue") ) { comboValue=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"comboTypes") ) { comboTypes=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"noCapValue") ) { noCapValue=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"offsetValue") ) { offsetValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthValue") ) { healthValue=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"settingText") ) { settingText=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"settingDesc") ) { settingDesc=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"accuracyType") ) { accuracyType=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"genericOnOff") ) { genericOnOff=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ghostTapDesc") ) { ghostTapDesc=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"accuracyTypes") ) { accuracyTypes=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"configSelected") ) { configSelected=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"randomTapValue") ) { randomTapValue=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"randomTapTypes") ) { randomTapTypes=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"canChangeItems") ) { canChangeItems=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"leftRightCount") ) { leftRightCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"controlSchemes") ) { controlSchemes=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"accuracyTypeInt") ) { accuracyTypeInt=inValue.Cast< int >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"healthDrainValue") ) { healthDrainValue=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"comboDisplayDesc") ) { comboDisplayDesc=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"selectedSomethin") ) { selectedSomethin=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"controlSchemesDesc") ) { controlSchemesDesc=inValue.Cast< ::Array< ::String > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ConfigMenu_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"exitTo") ) { exitTo=ioValue.Cast<  ::flixel::FlxState >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"startSong") ) { startSong=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

void ConfigMenu_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("configText",8f,d8,44,7a));
	outFields->push(HX_("descText",9e,53,35,f3));
	outFields->push(HX_("tabDisplay",6d,1c,22,7d));
	outFields->push(HX_("configSelected",3d,cf,28,69));
	outFields->push(HX_("offsetValue",de,02,39,ca));
	outFields->push(HX_("accuracyType",93,35,79,37));
	outFields->push(HX_("accuracyTypeInt",1c,0d,d8,63));
	outFields->push(HX_("accuracyTypes",80,ab,95,52));
	outFields->push(HX_("healthValue",35,11,3b,78));
	outFields->push(HX_("healthDrainValue",55,b0,ac,86));
	outFields->push(HX_("comboValue",43,ec,ad,3f));
	outFields->push(HX_("comboTypes",4b,dd,c0,28));
	outFields->push(HX_("downValue",af,53,ce,47));
	outFields->push(HX_("glowValue",a4,c1,95,61));
	outFields->push(HX_("randomTapValue",31,27,63,fa));
	outFields->push(HX_("randomTapTypes",39,18,76,e3));
	outFields->push(HX_("noCapValue",60,3f,60,5d));
	outFields->push(HX_("scheme",25,20,c1,40));
	outFields->push(HX_("dimValue",09,8d,ce,bf));
	outFields->push(HX_("tabKeys",e9,b6,7c,3f));
	outFields->push(HX_("canChangeItems",40,d2,3c,c3));
	outFields->push(HX_("leftRightCount",3a,26,f8,80));
	outFields->push(HX_("genericOnOff",f9,31,b6,06));
	outFields->push(HX_("settingText",5d,e2,32,d1));
	outFields->push(HX_("settingDesc",01,74,9f,c6));
	outFields->push(HX_("ghostTapDesc",c5,02,c2,f3));
	outFields->push(HX_("comboDisplayDesc",05,d4,c2,c8));
	outFields->push(HX_("controlSchemes",d1,92,31,9b));
	outFields->push(HX_("controlSchemesDesc",c2,59,61,8c));
	outFields->push(HX_("selectedSomethin",c8,ec,fb,99));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ConfigMenu_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(ConfigMenu_obj,configText),HX_("configText",8f,d8,44,7a)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(ConfigMenu_obj,descText),HX_("descText",9e,53,35,f3)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(ConfigMenu_obj,tabDisplay),HX_("tabDisplay",6d,1c,22,7d)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,configSelected),HX_("configSelected",3d,cf,28,69)},
	{::hx::fsFloat,(int)offsetof(ConfigMenu_obj,offsetValue),HX_("offsetValue",de,02,39,ca)},
	{::hx::fsString,(int)offsetof(ConfigMenu_obj,accuracyType),HX_("accuracyType",93,35,79,37)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,accuracyTypeInt),HX_("accuracyTypeInt",1c,0d,d8,63)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,accuracyTypes),HX_("accuracyTypes",80,ab,95,52)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,healthValue),HX_("healthValue",35,11,3b,78)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,healthDrainValue),HX_("healthDrainValue",55,b0,ac,86)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,comboValue),HX_("comboValue",43,ec,ad,3f)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,comboTypes),HX_("comboTypes",4b,dd,c0,28)},
	{::hx::fsBool,(int)offsetof(ConfigMenu_obj,downValue),HX_("downValue",af,53,ce,47)},
	{::hx::fsBool,(int)offsetof(ConfigMenu_obj,glowValue),HX_("glowValue",a4,c1,95,61)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,randomTapValue),HX_("randomTapValue",31,27,63,fa)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,randomTapTypes),HX_("randomTapTypes",39,18,76,e3)},
	{::hx::fsBool,(int)offsetof(ConfigMenu_obj,noCapValue),HX_("noCapValue",60,3f,60,5d)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,scheme),HX_("scheme",25,20,c1,40)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,dimValue),HX_("dimValue",09,8d,ce,bf)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,tabKeys),HX_("tabKeys",e9,b6,7c,3f)},
	{::hx::fsBool,(int)offsetof(ConfigMenu_obj,canChangeItems),HX_("canChangeItems",40,d2,3c,c3)},
	{::hx::fsInt,(int)offsetof(ConfigMenu_obj,leftRightCount),HX_("leftRightCount",3a,26,f8,80)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,genericOnOff),HX_("genericOnOff",f9,31,b6,06)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,settingText),HX_("settingText",5d,e2,32,d1)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,settingDesc),HX_("settingDesc",01,74,9f,c6)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,ghostTapDesc),HX_("ghostTapDesc",c5,02,c2,f3)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,comboDisplayDesc),HX_("comboDisplayDesc",05,d4,c2,c8)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,controlSchemes),HX_("controlSchemes",d1,92,31,9b)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(ConfigMenu_obj,controlSchemesDesc),HX_("controlSchemesDesc",c2,59,61,8c)},
	{::hx::fsBool,(int)offsetof(ConfigMenu_obj,selectedSomethin),HX_("selectedSomethin",c8,ec,fb,99)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo ConfigMenu_obj_sStaticStorageInfo[] = {
	{::hx::fsBool,(void *) &ConfigMenu_obj::startSong,HX_("startSong",57,9d,4b,05)},
	{::hx::fsObject /*  ::flixel::FlxState */ ,(void *) &ConfigMenu_obj::exitTo,HX_("exitTo",39,c4,e0,bf)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String ConfigMenu_obj_sMemberFields[] = {
	HX_("configText",8f,d8,44,7a),
	HX_("descText",9e,53,35,f3),
	HX_("tabDisplay",6d,1c,22,7d),
	HX_("configSelected",3d,cf,28,69),
	HX_("offsetValue",de,02,39,ca),
	HX_("accuracyType",93,35,79,37),
	HX_("accuracyTypeInt",1c,0d,d8,63),
	HX_("accuracyTypes",80,ab,95,52),
	HX_("healthValue",35,11,3b,78),
	HX_("healthDrainValue",55,b0,ac,86),
	HX_("comboValue",43,ec,ad,3f),
	HX_("comboTypes",4b,dd,c0,28),
	HX_("downValue",af,53,ce,47),
	HX_("glowValue",a4,c1,95,61),
	HX_("randomTapValue",31,27,63,fa),
	HX_("randomTapTypes",39,18,76,e3),
	HX_("noCapValue",60,3f,60,5d),
	HX_("scheme",25,20,c1,40),
	HX_("dimValue",09,8d,ce,bf),
	HX_("tabKeys",e9,b6,7c,3f),
	HX_("canChangeItems",40,d2,3c,c3),
	HX_("leftRightCount",3a,26,f8,80),
	HX_("genericOnOff",f9,31,b6,06),
	HX_("settingText",5d,e2,32,d1),
	HX_("settingDesc",01,74,9f,c6),
	HX_("ghostTapDesc",c5,02,c2,f3),
	HX_("comboDisplayDesc",05,d4,c2,c8),
	HX_("controlSchemes",d1,92,31,9b),
	HX_("controlSchemesDesc",c2,59,61,8c),
	HX_("create",fc,66,0f,7c),
	HX_("selectedSomethin",c8,ec,fb,99),
	HX_("update",09,86,05,87),
	HX_("changeItem",a3,fa,08,20),
	HX_("textUpdate",96,06,f6,bd),
	HX_("getSetting",9a,67,09,77),
	HX_("exit",1e,f7,1d,43),
	HX_("secretPresetTest",e1,c1,21,9a),
	HX_("writeToConfig",9c,9e,b2,b2),
	::String(null()) };

static void ConfigMenu_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ConfigMenu_obj::startSong,"startSong");
	HX_MARK_MEMBER_NAME(ConfigMenu_obj::exitTo,"exitTo");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ConfigMenu_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ConfigMenu_obj::startSong,"startSong");
	HX_VISIT_MEMBER_NAME(ConfigMenu_obj::exitTo,"exitTo");
};

#endif

::hx::Class ConfigMenu_obj::__mClass;

static ::String ConfigMenu_obj_sStaticFields[] = {
	HX_("startSong",57,9d,4b,05),
	HX_("exitTo",39,c4,e0,bf),
	::String(null())
};

void ConfigMenu_obj::__register()
{
	ConfigMenu_obj _hx_dummy;
	ConfigMenu_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("config.ConfigMenu",cd,17,9f,3b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ConfigMenu_obj::__GetStatic;
	__mClass->mSetStaticField = &ConfigMenu_obj::__SetStatic;
	__mClass->mMarkFunc = ConfigMenu_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ConfigMenu_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ConfigMenu_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ConfigMenu_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ConfigMenu_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ConfigMenu_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ConfigMenu_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ConfigMenu_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_39aa2ae3e97c53ec_26_boot)
HXDLIN(  26)		startSong = true;
            	}
}

} // end namespace config
